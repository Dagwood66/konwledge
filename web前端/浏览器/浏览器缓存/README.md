# 浏览器缓存  
    浏览器缓存分为强缓存和协商缓存  
> 1. 浏览器在加载资源时，先根据这个资源的一些http header判断它是否命中强缓存，强缓存如果命中，浏览器直接从自己的缓存中读取资源，不会发请求到服务器。比如某个css文件，如果浏览器在加载它所在的网页时，这个css文件的缓存配置命中了强缓存，浏览器就直接从缓存中加载这个css，连请求都不会发送到网页所在服务器；  
> 2. 当强缓存没有命中的时候，浏览器一定会发送一个请求到服务器，通过服务器端依据资源的另外一些http header验证这个资源是否命中协商缓存，如果协商缓存命中，服务器会将这个请求返回，但是不会返回这个资源的数据，而是告诉客户端可以直接从缓存中加载这个资源，于是浏览器就又会从自己的缓存中去加载这个资源；
> 3. 强缓存与协商缓存的共同点是：如果命中，都是从客户端缓存中加载资源，而不是从服务器加载资源数据；区别是：强缓存不发请求到服务器，协商缓存会发请求到服务器。
> 4. 当协商缓存也没有命中的时候，浏览器直接从服务器加载资源数据。  
# 强缓存的原理  
    强缓存命中http状态为200 size=form cache。  
    强缓存是利用 Expires 或者 Cache-Control 这两个http response header实现的,它们都用来表示资源在客户端缓存的有效期。
    Expires Cache-Control 可以同时存在，同时存在时 Cache-Control优先级高于Expires。
## Expires  
    Expores是http1.0提出的一个表示资源过期时间的header，它描述一个绝对时间，由服务器返回，用GMT格式的字符串表示
> Expires原理
> 1. 浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时,在response的header加上Expires的header。
> 2. 浏览器在接收到这个资源后，会把这个资源连同所有的response header一起缓存下来(所以缓存命中的请求返回的header并不是来自服务器，而是之前缓存的header)。
> 3. 浏览器在请求这个资源时，先从缓存中查找，找到这个资源后，拿出它的Expires跟当前请求时间比较，如果请求时间在Expires指定的时间之前，就能命中缓存，否则就不行。
> 4. 如果缓存没有命中，浏览器直接从服务器加载资源时，Expires Header在重新加载的时候会被更新。
## Cache-Control
    Expires是较老的强缓存管理header，由于它是服务器返回的一个绝对时间，在服务器时间与客户端时间相差较大时，缓存管理容易出现问题，比如随意修改下客户端时间，就能影响缓存命中的结果。  
    所以在http1.1的时候，提出了一个新的header，就是Cache-Control，这是一个相对时间，在配置缓存的时候，以秒为单位，用数值表示，如：Cache-Control:max-age=315360000。
    Cache-Control描述的是一个相对时间，在进行缓存命中的时候，都是利用客户端时间进行判断，所以相比较Expires，Cache-Control的缓存管理更有效，安全一些。
> Cache-Control原理
> 1. 浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在response的header加上Cache-Control的header
> 2. 浏览器在接受到这个资源后，会把这个资源连同所有response header一起缓存下来。
> 3. 浏览器再请求这个资源时，先从缓存中寻找，找到这个资源后，根据它第一次的请求时间和Cache-Control设定的有效期，计算出一个资源过期时间，在拿这个过期时间跟当前的请求时间比较，如果请求时间在过期之前，就能命中缓存，否则不行。
> 4. 如果缓存没有命中，浏览器直接从服务器加载资源时，Cache-Control Header在重新加载的时候会被更新。
# 强缓存的管理  
# 强缓存的应用
    强缓存是前端性能优化最有力的工具，没有之一，对于有大量静态资源的网页，一定要利用强缓存，提高响应速度。通常的做法是，为这些静态资源全部配置一个超时时间超长的Expires或Cache-Control，这样用户在访问网页时，只会在第一次加载时从服务器请求静态资源，其它时候只要缓存没有失效并且用户没有强制刷新的条件下都会从自己的缓存中加载。
# 协商缓存的原理
    当浏览器对某个资源的请求没有命中强缓存，就会发一个请求到服务器，验证协商缓存是否命中，如果协商缓存命中，请求响应返回的http状态为304并且会显示一个Not Modified的字符串。
> Last-Modified,If-Modified-Since 原理
> 1. 浏览器第一次跟服务器请求资源，服务器在返回这个资源的同时，在response的header加上Last-Modified的header，这个header表示这个资源在服务器上的最后修改时间    
> 2. 浏览器再次跟服务器请求这个资源时，在request的header上加上if-Modified-Since的header，这个header的值就是上一次请求返回的Last-Modified的值。
> 3. 服务器再次收到资源请求时，根据浏览器传过来的If-modified-Since和资源在服务器上的最后修改时间判断资源是否有变化，如果没有变化则返回304 Not Modified,但是不会返回资源内容，如果有变化，就正常返回资源内容。当服务器返回304 Not Modified的响应时，response header中不会再添加Last-Modified的header,因为既然资源没有变化,那么Last-Modified也就不会改变，这是服务器返回304的response header.
> 4. 浏览器收到304的响应后，就会从缓存中加载资源。
> 5. 如果协商缓存没有命中，浏览器直接从服务器加载资源时，Last-Modified Header在重新加载的时候会被更新，下次请求时，If-Modified-Since会启用上次返回的Last-Modified值。   
> ETag,If-None-Match 原理
> 1. 浏览器第一次跟服务器请求一个资源,服务器在返回这个资源的同时，在response的header加上ETag的header，这个header是服务器根据当前请求的资源生成的唯一标识，这个标识是服务器根据当前请求资源生成的一个唯一标识，这个唯一标识是一个字符串，只要资源有变化这个串就不同，跟最后的修改时间没关系，所以能很好的补充Last-Modified的问题。
> 2. 浏览器再次跟服务器请求这个资源时，在request的header加上If-None-Match的header，这个header的值就是上一次请求时返回的ETag的值.
> 3. 服务器再次收到资源请求时，根据浏览器传过来If-None-Match和在根据资源生成一个新的ETag,如果这两个值相同就说明资源没有变化，否则就是有变化，如果没有变化则返回304 Not Modified,但是不会返回资源内容。如果变化，就正常返回资源内容。与Last-Modified不一样的是，当服务器返回304 Not Modified的响应时，由于ETag重新生成过，response header中会把这个ETag返回，即使这个ETag跟之前的没有变化。
> 4. 浏览器收到304的响应后，就会从缓存中加载资源。
# 协商缓存的管理
    协商缓存跟强缓存不一样，强缓存不发请求到服务器，所以有时候资源更新了浏览器还不知道，但是协商缓存会发请求到服务器，所以资源是否更新，服务器肯定知道。大部分web服务器都默认开启协商缓存，而且是同时启用【Last-Modified，If-Modified-Since】和【ETag、If-None-Match】
    如果没有协商缓存，每个到服务器的请求，就都得返回资源内容，这样服务器的性能会极差。
    Last-Modified,If-Modified-Since,ETag,If-None-Match一般是同时启用，这是为了处理Last-Modified不可靠的情况。
    分布式系统里多台机器间文件的Last-Modified必须保持一致，以免负载均衡到不同机器导致比对失败；
    分布式系统尽量关闭掉ETag(每台机器生成的ETag都会不一样）
    协商缓存需要配合强缓存使用，因为如果不启用强缓存的话，协商缓存根本没有意义。
# 浏览器行为对缓存的影响
> 如果资源已经被浏览器缓存下来，在缓存失效之前，再次请求时，默认会先检查是否命中强缓存，如果强缓存命中则直接读取缓存，如果强缓存没有命中则发请求到服务器检查是否命中协商缓存，如果协商缓存命中，则告诉浏览器还是可以从缓存读取，否则才从服务器返回最新的资源。这是默认的处理方式，这个方式可能被浏览器的行为改变：  
> 当ctrl+f5强制刷新网页时，直接从服务器加载，跳过强缓存和协商缓存；  
> 当f5刷新网页时，跳过强缓存，但是会检查协商缓存；  
# 参考  
> [浏览器缓存知识小结及应用 - 流云诸葛 - 博客](https://www.cnblogs.com/lyzg/p/5125934.html)